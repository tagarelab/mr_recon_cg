"""
   Name: algebra.py
   Purpose: Algebraic functions for the project
   Created on: 2/15/2024
   Created by: Heng Sun
   Additional Notes: 
"""

import numpy as np
import scipy as sp
from scipy.interpolate import RegularGridInterpolator
import warnings
import visualization as vis


def get_rotation_to_vector(vectors, target_vectors):
    vectors = np.array(vectors)
    target_vectors = np.array(target_vectors)

    if vectors.shape[0] != 3:
        raise ValueError('Input vectors must be of shape (3, n)')
    if target_vectors.shape[0] != 3:
        raise ValueError('Target vector must be of shape (3, n) or (3,)')
    if len(target_vectors.shape) == 1 or target_vectors.shape[1] == 1:
        if len(target_vectors.shape) == 1:
            target_vectors = target_vectors[:, np.newaxis]
        target_vectors = np.tile(target_vectors, (1, vectors.shape[1]))

    # Initialize arrays to store axes and angles
    axes = np.zeros(vectors.shape)
    angles = np.ones(vectors.shape[1]) * np.pi

    for i in range(vectors.shape[1]):
        v = vectors[:, i]
        t = target_vectors[:, i]
        t_norm = np.linalg.norm(t)
        v_norm = np.linalg.norm(v)
        if t_norm == 0:
            raise ValueError('Target vector cannot be zero.')
        elif v_norm == 0:
            axes[:, i] = np.array([1, 0, 0])
            angles[i] = 0  # no rotation, any axis will do
            # raise ValueError('Zero-vector has no direction and cannot be rotated')
        else:
            axis = (v / v_norm + t / t_norm) / 2
            axes[:, i] = axis / np.linalg.norm(axis)

        # vis.quiver3d(np.array([v, t, axes[:, i]]).T,
        #              xlim=[-2, 2], ylim=[-2, 2], zlim=[-2, 2],
        #              label=[f'Orig{v}', f'Target{axes[:, i]}', f'Rot Axis{axes[:, i]}'],
        #              title='Rotation Axis')

    return axes, angles


def create_perpendicular_unit_vectors(w, m=None):
    """
    Given an array of 3D vectors w, return three arrays of unit vectors u, v, w such that:
    - w is the unit vector with the same direction as w (the input vectors)
    - u and v are perpendicular to each other and to w
    - if m is provided, u is pointing in the direction of m

    :param w: array of 3D vectors with shape (3, n)
    :return: three arrays of unit vectors u, v, w each with shape (3, n)
    """
    single_vector = False
    # Handle the case where w is a single vector
    if w.ndim == 1:
        w = w[:, np.newaxis]
        single_vector = True

    # Ensure w is a 2D array with shape (3, n)
    w = np.atleast_2d(w)
    assert w.shape[0] == 3, "Input must be an array with the first dimension of size 3"

    # # Normalize all vectors w
    # w_norms = np.linalg.norm(w, axis=0)
    # w_unit = w / w_norms
    #
    # u_unit = np.empty_like(w_unit)
    # v_unit = np.empty_like(w_unit)
    #
    # for i in range(w_unit.shape[1]):
    #     wi = w_unit[:, i]
    #
    #     # Create a vector that is not parallel to wi to ensure we can create a perpendicular vector
    #     if np.allclose(wi, [1, 0, 0]):
    #         # wi is parallel to the x-axis, choose the y-axis
    #         temp_vector = np.array([0, 1, 0])
    #     else:
    #         # otherwise, choose the x-axis
    #         temp_vector = np.array([1, 0, 0])
    #
    #     # Use the cross product to find a vector that is perpendicular to wi
    #     ui = np.cross(wi, temp_vector)
    #     ui = ui / np.linalg.norm(ui)
    #
    #     # Use the cross product to find the third vector that is perpendicular to both wi and ui
    #     vi = np.cross(wi, ui)
    #     vi = vi / np.linalg.norm(vi)
    #
    #     u_unit[:, i] = ui
    #     v_unit[:, i] = vi

    # Normalize w to get the unit vector w
    w_norm = np.linalg.norm(w, axis=0)
    w_unit = w / w_norm

    # Initialize u and v arrays
    u_unit = np.zeros_like(w_unit)
    v_unit = np.zeros_like(w_unit)

    for i in range(w_unit.shape[1]):
        w_i = w_unit[:, i]

        # Choose or compute m
        if m is not None:
            m_i = np.asarray(m)[:, i]
        else:
            # If no m is provided, use a default vector that is unlikely to be parallel to w
            m_i = np.array([1.0, 0.0, 0.0])
            if np.allclose(w_i, m_i):
                m_i = np.array([0.0, 1.0, 0.0])

        # Compute u by removing the component of m along w
        u_i = m_i - np.dot(m_i, w_i) * w_i
        u_i = u_i / np.linalg.norm(u_i)

        # Compute v as the cross product of w and u
        v_i = np.cross(w_i, u_i)
        v_i = v_i / np.linalg.norm(v_i)

        u_unit[:, i] = u_i
        v_unit[:, i] = v_i

    # If the original input was a single vector, return a tuple of unit vectors
    if single_vector:
        return u_unit[:, 0], v_unit[:, 0], w_unit[:, 0]

    return u_unit, v_unit, w_unit


def auto_corr(signal, max_lag=10):
    """
    Calculate the autocorrelation of the signal
    This function is generated by Github Copilot and edited & tested by the author.
    """
    signal = np.fft.fftshift(np.fft.fft(signal))
    signal = np.abs(signal)
    signal = np.fft.ifft(np.fft.fftshift(signal))
    return signal[:max_lag] / signal[0]


def normalized_cross_correlation(signal1, signal2, do_ifftshift=False):
    """
    Compute the normalized cross-correlation between two signals.
    This function is generated by Github Copilot and edited & tested by the author.

    Parameters:
    - signal1 (numpy.ndarray): First input signal.
    - signal2 (numpy.ndarray): Second input signal.

    Returns:
    - numpy.ndarray: Normalized cross-correlation.
    """
    # Ensure the signals are numpy arrays
    signal1 = np.asarray(signal1)
    signal2 = np.asarray(signal2)

    # Compute the cross-correlation
    cross_corr = sp.signal.correlate(signal1, signal2, mode='full')  # TODO: check this function -> boundry effect

    # fftshift the cross-correlation
    if do_ifftshift:
        cross_corr = np.fft.ifftshift(cross_corr)

    # Normalize the cross-correlation
    norm_factor = np.sqrt(np.sum(np.abs(signal1)**2) * np.sum(np.abs(signal2)**2))
    normalized_cross_corr = cross_corr / norm_factor

    return normalized_cross_corr


def linear_to_db(x):
    return 20 * np.log10(x)


def db_to_linear(x):
    return 10 ** (x / 20)


# def parallel_component(v, u):
#     """
#     Calculate the parallel component of vector v to vector u.
#     np.dot(v, u) / np.linalg.norm(u) is the parallel component of v to u.
#     u / np.linalg.norm(u) is the unit vector of u.
#     The parallel component of v to u is then multiplied by the unit vector of u.
#
#     :param v: vector v
#     :param u: vector u
#     :return: parallel component of vector v to vector u
#     """
#     return np.dot(v, u) / np.linalg.norm(u) ** 2 * u
#
#
# def perpendicular_component(v, u):
#     """
#     Calculate the perpendicular component of vector v to vector u.
#
#     :param v: vector v
#     :param u: vector u
#     :return: perpendicular component of vector v to vector u
#     """
#     return v - parallel_component(v, u)


def parallel_component(v, u):
    """
    Calculate the parallel component of vector v to vector u.
    np.dot(v, u) / np.linalg.norm(u) is the parallel component of v to u.
    u / np.linalg.norm(u) is the unit vector of u.
    The parallel component of v to u is then multiplied by the unit vector of u.

    :param v: vector v or an array/matrix of vectors with the first dimension of size 3.
    :param u: vector u or an array/matrix of vectors with the first dimension of size 3.
    :return: parallel component of vector v to vector u
    """

    # Check dimensions and ensure consistent shape
    if not (v.shape == u.shape and v.shape[0] == 3):
        raise ValueError(
            "Input vectors v and u must have the same shape with the first dimension of size 3")

    # Reshape to handle both 1D and 2D/3D cases
    if v.ndim == 1:
        v = v[:, np.newaxis]
        u = u[:, np.newaxis]

    # Calculate the dot product element-wise
    dot_product = np.einsum('ij...,ij...->j...', v, u)

    # Calculate the norm of u
    norm_u = np.linalg.norm(u, axis=0)

    # Calculate the parallel component element-wise
    parallel_comp = (dot_product / norm_u ** 2) * u

    # Return the result in the original shape
    if v.shape[1] == 1:
        return parallel_comp[:, 0]

    return parallel_comp


def perpendicular_component(v, u):
    """
    Calculate the perpendicular component of vector v to vector u.

    :param v: vector v or an array/matrix of vectors with the first dimension of size 3.
    :param u: vector u or an array/matrix of vectors with the first dimension of size 3.
    :return: perpendicular component of vector v to vector u
    """

    # Check dimensions and ensure consistent shape
    if not (v.shape == u.shape and v.shape[0] == 3):
        raise ValueError(
            "Input vectors v and u must have the same shape with the first dimension of size 3")

    # Calculate the perpendicular component as v - parallel_component(v, u)
    perpendicular_comp = v - parallel_component(v, u)

    return perpendicular_comp


def rot_mat(u, theta):
    """
    Generate matrix to perform rotation on a 3D vector.
    Reference: https://en.wikipedia.org/wiki/Rotation_matrix
    :param u: the fixed direction, with x,y,z component
    :param theta: rotate this much
    :return:
    """
    # Normalize the vector
    u = u / np.linalg.norm(u)

    c = np.cos(theta)
    s = np.sin(theta)

    return np.array([[u[0] ** 2 * (1 - c) + c, u[0] * u[1] * (1 - c) - u[2] * s, u[0] * u[2] * (1 - c) + u[1] * s],
                     [u[0] * u[1] * (1 - c) + u[2] * s, u[1] ** 2 * (1 - c) + c, u[1] * u[2] * (1 - c) - u[0] * s],
                     [u[0] * u[2] * (1 - c) - u[1] * s, u[1] * u[2] * (1 - c) - u[0] * s, u[2] ** 2 * (1 - c) + c]])


def interp_by_pts(M, x_axis, y_axis, z_axis, intrp_pts, method='linear', empty_val=0):
    interpolator = RegularGridInterpolator((x_axis, y_axis, z_axis), M, method=method)
    interpolated_matrix = np.empty(intrp_pts.shape[:-1])
    # check if the interpolation points are within the range of the raw data
    if np.any(intrp_pts < np.array([x_axis[0], y_axis[0], z_axis[0]])) or np.any(
            intrp_pts > np.array([x_axis[-1], y_axis[-1], z_axis[-1]])):
        warnings.warn(
            'Warning: Interpolation points are out of range of the raw data. Fill with empty_val: %.2f' % empty_val)
        for index, _ in np.ndenumerate(intrp_pts[:, :, :, 0]):
            point = intrp_pts[index[0], index[1], index[2], :]
            if np.any(point < np.array([x_axis[0], y_axis[0], z_axis[0]])) or np.any(
                    point > np.array([x_axis[-1], y_axis[-1], z_axis[-1]])):
                interpolated_matrix[index] = empty_val
            else:
                interpolated_matrix[index] = interpolator(point)
    else:
        interpolated_matrix = interpolator(intrp_pts)
    return interpolated_matrix


def gen_interp_pts(x_intrp, y_intrp, z_intrp):
    # Dimensions of the expanded field taken from the raw data
    intrp_pts = np.array(np.meshgrid(x_intrp, y_intrp, z_intrp, indexing='ij')).T
    return intrp_pts


def gen_interp_axis(x_axis, y_axis, z_axis, x_pts, y_pts, z_pts):
    # Dimensions of the expanded field taken from the raw data
    x_intrp = np.linspace(x_axis[0], x_axis[-1], x_pts)
    y_intrp = np.linspace(y_axis[0], y_axis[-1], y_pts)
    z_intrp = np.linspace(z_axis[0], z_axis[-1], z_pts)
    return x_intrp, y_intrp, z_intrp


def interp_3dmat(M, x_axis, y_axis, z_axis, x_pts, y_pts, z_pts, method='linear'):
    """
    Interpolate a 3D matrix to new dimensions x, y, and z.
    This function is adapted from a MATLAB function by Github Copilot and edited & tested by the author.

    Inputs:
    - M: Input 3D matrix.
    - x_pts: Number of desired points along the first dimension (X).
    - y_pts: Number of desired points along the second dimension (Y).
    - z_pts: Number of desired points along the third dimension (Z).

    Output:
    - interpolated_matrix: Interpolated 3D matrix with dimensions x, y, z.
    """

    x_intrp, y_intrp, z_intrp = gen_interp_axis(x_axis, y_axis, z_axis, x_pts, y_pts, z_pts)
    intrp_pts = gen_interp_pts(x_intrp, y_intrp, z_intrp)
    interpolated_matrix = interp_by_pts(M, x_axis, y_axis, z_axis, intrp_pts, method=method)

    return interpolated_matrix, x_intrp, y_intrp, z_intrp


def vec2mesh(mag, x_coord, y_coord, z_coord, x_dim=None, y_dim=None, z_dim=None, empty_val=None):
    """
    Transform from vector representation to mesh representation,
    assuming even interpolation.
    This function is adapted from a MATLAB function by Github Copilot and edited & tested by the author.

    """
    if x_dim is not None:
        x_M = np.linspace(np.min(x_coord), np.max(x_coord), x_dim)
    else:
        x_M = np.unique(x_coord)
        x_dim = len(x_M)
    if y_dim is not None:
        y_M = np.linspace(np.min(y_coord), np.max(y_coord), y_dim)
    else:
        y_M = np.unique(y_coord)
        y_dim = len(y_M)
    if z_dim is not None:
        z_M = np.linspace(np.min(z_coord), np.max(z_coord), z_dim)
    else:
        z_M = np.unique(z_coord)
        z_dim = len(z_M)

    if mag.ndim == 1:
        mag = np.expand_dims(mag, axis=0)
    if mag.shape[1] != x_dim * y_dim * z_dim:
        if empty_val is None:
            raise ValueError('Error: target dimensions does not meet vector dimension.')
        else:
            warnings.warn("Warning: target dimensions does not meet vector dimension. Filling with empty_val: %.2f"
                          % empty_val)

    X_M, Y_M, Z_M = np.meshgrid(x_M, y_M, z_M, indexing='ij')

    mag_mesh = np.zeros((mag.shape[0], x_dim, y_dim, z_dim))
    for dd in range(mag.shape[0]):
        for xx in range(x_dim):
            for yy in range(y_dim):
                for zz in range(z_dim):
                    ind = np.argmax(
                        (x_coord == X_M[xx, yy, zz]) & (y_coord == Y_M[xx, yy, zz]) & (z_coord == Z_M[xx, yy,
                        zz]))
                    try:
                        mag_mesh[dd, xx, yy, zz] = mag[dd, ind]
                    except ValueError:
                        # print('ValueError: ', ind)    # turn this on for debugging
                        mag_mesh[dd, xx, yy, zz] = empty_val
    if mag.shape[0] == 1:
        mag_mesh = np.squeeze(mag_mesh, axis=0)

    return mag_mesh, x_M, y_M, z_M


def complex2array(x):
    """
    Convert a complex array to a real array.
    This function is drafted by Github Copilot and edited & tested by the author.

    Parameters:
    - x (numpy.ndarray): The input complex array.

    Returns:
    - numpy.ndarray: The real array.
    """
    return np.concatenate((np.real(x), np.imag(x)), axis=-1)


def array2complex(x):
    """
    Convert a real array to a complex array.
    This function is drafted by Github Copilot and edited & tested by the author.

    Parameters:
    - x (numpy.ndarray): The input real array.

    Returns:
    - numpy.ndarray: The complex array.
    """
    return x[..., :x.shape[-1] // 2] + 1j * x[..., x.shape[-1] // 2:]


def snr(signal, noi_range=None):
    if signal.ndim == 2:
        signal = np.mean(signal, axis=1)
    sig_abs = np.abs(signal)
    if noi_range is None:
        warnings.warn("Warning when calculating snr: Noise range is not specified. Using the whole signal.")
        noi_range = [0, len(sig_abs)]
    noi_std = np.std(sig_abs[noi_range[0]:noi_range[1]])
    noi_avg = np.mean(sig_abs[noi_range[0]:noi_range[1]])  # take off the noise floor when calculating SNR
    return (np.max(sig_abs) - noi_avg) / noi_std
