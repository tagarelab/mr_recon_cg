"""
   Name: dephasing.py
   Purpose: Methods for simulating dephasing
   Created on: 9/17/2024
   Created by: Heng Sun
   Additional Notes: 
"""

import numpy as np
import scipy as sp


def Bloch_matrixes(omega_t, M_t, T1, T2, M_0):
    """
    Simulate the Bloch equation for any time point.
    This function is generated by Github Copilot and edited & tested by the author.

    Parameters:
    - omega_t (numpy.ndarray): Frequency at time t.
    - M_t (numpy.ndarray): Magnetization at time t.
    - T1 (numpy.ndarray): T1 relaxation time.
    - T2 (numpy.ndarray): T2 relaxation time.
    - M_0 (numpy.ndarray): Initial magnetization.

    Returns:
    - numpy.ndarray: Magnetization at time t.
    """
    # if M_0 is None:
    #     M_0 = np.linalg.norm(M_t[:, :, 0], axis=0)  #TODO: is this the correct M0?

    # also handles the case when T1 and T2 are integers (same for all voxels)
    if len(T1) == 1:
        T1 = np.ones(omega_t.shape[1]) * T1
    if len(T2) == 1:
        T2 = np.ones(omega_t.shape[1]) * T2

    # Initialize the Bloch matrix
    Bloch = np.zeros((3, 3, omega_t.shape[1], omega_t.shape[2]), dtype=complex)
    Bloch_add = np.zeros((3, omega_t.shape[1]), dtype=complex)

    # Compute the Bloch matrix
    for i in range(omega_t.shape[1]):
        for k in range(omega_t.shape[2]):
            Bloch[:, :, i, k] = np.array([[-1 / T2[i], omega_t[2, i, k], -omega_t[1, i, k]],
                                          [-omega_t[2, i, k], -1 / T2[i], omega_t[0, i, k]],
                                          [omega_t[1, i, k], -omega_t[0, i, k], -1 / T1[i]]])
        Bloch_add[2, i] = M_0[i] / T1[i]
    return Bloch, Bloch_add


def M_t(M, T1, T2, t):
    """
    Simulate T1 and T2 dephasing of the megnetization M, given T1, T2 relaxation time and current time point t.
    This function is generated by Github Copilot and edited & tested by the author.

    Parameters:
    - M (numpy.ndarray): Initial magnetization.
    - T1 (numpy.ndarray): T1 relaxation time.
    - T2 (numpy.ndarray): T2 relaxation time.
    - t (numpy.ndarray): Time points (or current time point).

    Returns:
    - numpy.ndarray: Magnetization at time t.
    """
    # also handles the case when T1 and T2 are integers (same for all voxels)
    if len(T1) == 1:
        T1 = np.ones(M.shape[1]) * T1
    if len(T2) == 1:
        T2 = np.ones(M.shape[1]) * T2

    E1 = np.exp(-t / T1)
    E2 = np.exp(-t / T2)
    M_t = np.zeros((M.shape[0], M.shape[1], len(t)), dtype=complex)
    for i in range(len(t)):
        M_t[0, :, i] = M[0, :] * E2[i]
        M_t[1, :, i] = M[1, :] * E2[i]
        M_t[2, :, i] = M[2, :] * (1 - E1[i])

    return M_t


def M_t_operator(T1, T2, t):
    """
    Generate a matrix operator for the dephasing simulation.
    :param T1:
    :param T2:
    :param t:
    :return:
    """
    # Assert T1 and T2 are of the same length
    assert len(T1) == len(T2), "T1 and T2 must have the same length."

    # Create a meshgrid for the computation
    t_grid, T1_grid = np.meshgrid(t, T1)
    t_grid, T2_grid = np.meshgrid(t, T2)

    # Compute matrix E1 using element-wise operations
    E1 = np.exp(-t_grid / T1_grid)
    E2 = np.exp(-t_grid / T2_grid)

    # Construct the A matrix
    A = np.zeros((3, len(T1), len(t)))

    # Populate the A matrix
    A[0, :, :] = E2
    A[1, :, :] = E2
    A[2, :, :] = 1 - E1

    return A
